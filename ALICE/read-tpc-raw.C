/// @file   read-tpc-raw.C
/// @author Matthias.Richter@scieq.net
/// @date   2015-01-06
/// @brief  Read TPC Raw Data and convert to tree
///
/// The macro illustrates the reading of TPC raw data files using the AliAltroRawStreamV3
/// decoder. The file names of input files are read from the standard input
/// Usage:
/// ls rawdata*.root | aliroot -b -q -l read-tpc-raw.C
/// # replace 'ls rawdata*.root' by appropriate command printing the raw file names
///
/// Changelog:
/// 2015-01-16 implementing huffman compression for raw signal differences
///            the huffman table is generated by running in training mode by
///            setting the variable bRunHuffmanTraining
/// 2015-01-20 adding several features:
///            - alternative compression scheme with cut of at high differences which
///              are likely not to be any physics signal; theoretically it should not
///              give any better compression if the method is still lossless, but we
///              are experimentalists ...
///            - estimation the compression factor wrt altro format
///            - control histogram for huffman code length
///            - pick of a sample channel with good physics signal
///            - normalization to minimum signal in the channel
///            - some simple spike detection

// for performance reasons, the macro is compiled into a temporary library
// and the compiled function is called
// Note: when using new classes the corresponding header files need to be
// add in the include section
#if defined(__CINT__) && !defined(__MAKECINT__)
{
  gSystem->AddIncludePath("-I$ROOTSYS/include -I$ALICE_ROOT/include");
  TString macroname=gInterpreter->GetCurrentMacroName();
  macroname+="+";
  gROOT->LoadMacro(macroname);
  read_tpc_raw();
}
#else

#include "AliRawReader.h"
#include "AliAltroRawStreamV3.h"
#include "AliHLTHuffman.h"
#include "TTree.h"
#include "TFile.h"
#include "TString.h"
#include "TSystem.h"
#include "TList.h"
#include "TPad.h"
#include "TH1.h"
#include "TGrid.h"
#include <cstdlib>
#include <iostream>
#include <iomanip>
#include <memory>
using namespace std;

void read_tpc_raw()
{
  ////////////////////////////////////////////////////////////////////////////////
  // macro configuration area
  const int maxEvent=-1;

  // signal bit length
  const int signalBitLength=10;
  const int signalRange=0x1<<signalBitLength;

  // the length of one channel
  const int maxChannelLength=1024;

  // huffman decoder settings
  const char* huffmanDecoderName="TPCRawSignalDifference";
  TString htfn=huffmanDecoderName;
  htfn+="_HuffmanTable.root";

  // run huffman training to produce the huffman table
  const bool bRunHuffmanTraining=false;

  // special mode to encode large differences
  // a cutoff parameter determines if large differences are encoded with only
  // one symbol for all such differences, however, the unencoded value is stored
  // to allow lossless decoding of the following differential signals
  const int signalDiffCutoff=0; //500;

  // spike detection setting
  const int spikeThreshold=500;
  const int spikeRelaxPercentage=2;
  const int sampleChannelMaxDiff=100;

  ////////////////////////////////////////////////////////////////////////////////

  int fileCount=0;
  int rangeErrorCount=0;
  TGrid* pGrid=NULL;
  TString line;
  TString targetFileName("tpc-raw-statistics.root");
  Int_t DDLNumber=-1;
  Int_t HWAddress=-1;
  Int_t RCUId=-1;
  Int_t ChannelLength=maxChannelLength;
  Int_t Signals[maxChannelLength];
  Int_t SignalDiffs[maxChannelLength];

  TTree *tpcrawstat = NULL;
  /// It seems, the tree-approach is not suitable for such an
  /// amount of data, the processing hangs when saving the tree
  // tpcrawstat=new TTree("tpcrawstat","TPC RAW statistics");
  if (tpcrawstat) {
    tpcrawstat->Branch("DDLNumber"    ,&DDLNumber    ,"DDLNumber/I");
    tpcrawstat->Branch("HWAddress"    ,&HWAddress    ,"HWAddress/I");
    tpcrawstat->Branch("RCUId"        ,&RCUId        ,"RCUId/I");
    tpcrawstat->Branch("ChannelLength",&ChannelLength,"ChannelLength/I");
    tpcrawstat->Branch("Signals"      ,Signals       ,"Signals[ChannelLength]/i");
    tpcrawstat->Branch("SignalDiffs"  ,SignalDiffs   ,"SignalDiffs[ChannelLength]/i");
  }

  TH1* hSignalDiff=NULL;
  Int_t binMargin=50; // some margin on both sides of the signal distribution
  Int_t nBins=2*(signalRange+binMargin)+1;
  hSignalDiff=new TH1D("hSignalDiff", "Differences in TPC RAW signal", nBins, -nBins/2, nBins/2);
  hSignalDiff->GetXaxis()->SetTitle("Signal(n+1) - Signal(n)");
  hSignalDiff->GetYaxis()->SetTitle("counts");
  hSignalDiff->GetYaxis()->SetTitleOffset(1.4);

  TH1* hSignalSpikeLength=new TH1F("hSignalSpikeLength", "Spike length of TPC Raw Signal", signalRange, 0, signalRange-1);
  hSignalSpikeLength->GetXaxis()->SetTitle("Signal spike length");
  hSignalSpikeLength->GetYaxis()->SetTitle("counts");
  hSignalSpikeLength->GetYaxis()->SetTitleOffset(1.4);

  TH1* hSampleChannel=NULL;
  TH1* hSampleChannelSignalDiff=NULL;

  TH1* hFactor=new TH1F("hFactor", "Huffman Compression for TPC Raw Signal Differences per Channel wrt full channel", 100, 0., 4.);
  hFactor->GetXaxis()->SetTitle("Compression factor (original bitlength/compressed bitlength)");
  hFactor->GetYaxis()->SetTitle("counts");
  hFactor->GetYaxis()->SetTitleOffset(1.4);

  TH1* hFactorCutoff=NULL;
  if (signalDiffCutoff>0) {
    TString title;
    title.Form("Huffman Compression for TPC Raw Signal Differences per Channel wrt full channel (cutoff %d)", signalDiffCutoff);
    hFactorCutoff=new TH1F("hFactorCutoff", title, 100, 0., 4.);
    hFactorCutoff->GetXaxis()->SetTitle("Compression factor (original bitlength/compressed bitlength)");
    hFactorCutoff->GetYaxis()->SetTitle("counts");
    hFactorCutoff->GetYaxis()->SetTitleOffset(1.4);
  }

  TH1* hFactorAltro=new TH1F("hFactorAltro", "Huffman Compression for TPC Raw Signal Differences per Channel wrt Altro channel payload", 400, 0., 4.);
  hFactorAltro->GetXaxis()->SetTitle("Compression factor (altro channel payload bitlegth/compressed bitlength)");
  hFactorAltro->GetYaxis()->SetTitle("counts");
  hFactorAltro->GetYaxis()->SetTitleOffset(1.4);

  TH1* hHuffmanCodeLength= new TH1F("hHuffmanCodeLength", "Huffman code length per signal difference", nBins, -nBins/2, nBins/2);
  hHuffmanCodeLength->GetXaxis()->SetTitle("Signal(n+1) - Signal(n)");
  hHuffmanCodeLength->GetYaxis()->SetTitle("Huffman code length");
  hHuffmanCodeLength->GetYaxis()->SetTitleOffset(1.4);

  // when storing differences, the actual difference value needs to be shifted
  // by the available value range, thus resulting in 1 bit more to be stored
  AliHLTHuffman* pHuffman=NULL;
  if (bRunHuffmanTraining) {
    pHuffman=new AliHLTHuffman(huffmanDecoderName, signalBitLength+1);
  } else {
    TFile* htf=TFile::Open(htfn);
    if (!htf || htf->IsZombie()) {
      cerr << "can not open file " << htfn << endl;
      cerr << "please run the macro in 'training' mode by setting bRunHuffmanTraining to true" << endl;
      return;
    }

    TObject* obj=NULL;
    htf->GetObject("TPCRawSignalDifference", obj);
    if (obj==NULL) {
      cout << "can not load Huffman decoder object " << huffmanDecoderName << " from file " << htfn << endl;
      return;
    }
    pHuffman=(AliHLTHuffman*)obj;
  }

  // the max signal in the current sample channel, if there is a new channel with higher signal,
  // the previous sample is discarded; channels with spikes and large differences > sampleChannelMaxDiff
  // are not considered good candidates
  Int_t sampleMaxSignal=0;

  line.ReadLine(cin);
  while (cin.good()) {
    if (pGrid==NULL && line.BeginsWith("alien://")) {
      pGrid=TGrid::Connect("alien");
      if (!pGrid) return;
    }
    cout << "open file " << fileCount << " '" << line << "'" << endl;    
    AliRawReader* rawreader=AliRawReader::Create(line);
    AliAltroRawStreamV3* altrorawstream=new AliAltroRawStreamV3(rawreader);
    if (!rawreader || !altrorawstream) {
      cerr << "error: can not open rawreader or altrostream for file " << line << endl;
    } else {
      fileCount++;
      rawreader->RewindEvents();
      int eventCount=0;
      if (!rawreader->NextEvent()) {
    	cout << "info: no events found in " << line << endl;
      } else {
    	do {
    	  cout << "processing file " << line << " event " << eventCount << endl;
    	  altrorawstream->Reset();
	  altrorawstream->SelectRawData("TPC");
    	  while (altrorawstream->NextDDL()) {
    	    DDLNumber=altrorawstream->GetDDLNumber();
	    cout << " reading event " << std::setw(4) << eventCount
		 << "  DDL " << std::setw(4) << DDLNumber
		 << " (" << line << ")"
		 << endl;
    	    while (altrorawstream->NextChannel()) {
    	      HWAddress=altrorawstream->GetHWAddress();
    	      memset(Signals, 0, maxChannelLength*sizeof(Int_t));
    	      memset(SignalDiffs, 0, maxChannelLength*sizeof(Int_t));
    	      if (!altrorawstream->IsChannelBad()) {
		int channelWordCount=0;
		// search for the minimum signal in this channel and subtract
		// this from all signals
		int channelMinSignal=signalRange;
    	    	while (altrorawstream->NextBunch()) {
    	    	  // process all signal values of the bunch and set the
    	    	  // according time bins in the buffer
    	    	  Int_t startTime=altrorawstream->GetStartTimeBin();
    	    	  Int_t bunchLength=altrorawstream->GetBunchLength();
		  channelWordCount+=bunchLength + 2; // +2 : bunch length and start time words
    	    	  const UShort_t* signals=altrorawstream->GetSignals();
    	    	  Int_t i=0;
    	    	  // cout << "reading bunch:"
    	    	  //      << "  DDL "       << DDLNumber
    	    	  //      << "  channel "   << HWAddress
    	    	  //      << "  startTime " << startTime
    	    	  //      << "  length "    << bunchLength
    	    	  //      << endl;
		  
    	    	  for (; i<bunchLength; i++) {
		    int timeBin=startTime-i;
    	    	    //if (timeBin>=maxChannelLength) continue;
		    if (channelMinSignal>signals[i]) channelMinSignal=signals[i];
    	    	    Signals[timeBin]=signals[i];
    	    	    SignalDiffs[timeBin]=Signals[timeBin];
    	    	    if (timeBin<maxChannelLength) {
    	    	      SignalDiffs[timeBin]-=Signals[timeBin+1];
    	    	    }
    	    	  } // end of bunch signal loop
    	    	  for (i=maxChannelLength-1; i>=0; i--) {
		    if (Signals[i]>=channelMinSignal) Signals[i]-=channelMinSignal;
		    if (i<maxChannelLength-1) SignalDiffs[i]=Signals[i]-Signals[i+1];
		    else SignalDiffs[i]=Signals[i]; // the first signal
		  }
    	    	} // end of bunch loop
		//	      cout << "   DDL " << DDLNumber << "  Channel " << HWAddress << endl;
		if (tpcrawstat) {
		  tpcrawstat->Fill();
		}

		Int_t bitcount=0;
		Int_t bitcountCutoff=0;
		Int_t spikeLength=0;

		// find a good candidate for the sample channel
		// - only moderate differnces
		// - no spike
		bool  sampleChannelCandidate=true;
		Int_t channelMaxSignal=0;

		// Note: in the Altro format the whole readout is backwards, thats why we
		// follow this scheme
		for (int i=maxChannelLength-1; i>=0; i--) {
		  if (hSignalDiff) {
		    if (Signals[i]>channelMaxSignal) channelMaxSignal=Signals[i];
		    hSignalDiff->Fill(SignalDiffs[i], 1);
		    sampleChannelCandidate&=SignalDiffs[i]>=-sampleChannelMaxDiff && SignalDiffs[i]<=sampleChannelMaxDiff;
		    if (spikeLength<=0 && (SignalDiffs[i]<-spikeThreshold || SignalDiffs[i]>spikeThreshold)) {
		      sampleChannelCandidate=false;
		      spikeLength=1;
		      Int_t spikeSum=SignalDiffs[i];
		      bool bHasSharpFallingEdge=false;
		      for (; i-spikeLength>=0; spikeLength++) {
			bHasSharpFallingEdge|=SignalDiffs[i-spikeLength]<-(spikeThreshold/2) || SignalDiffs[i-spikeLength]>(spikeThreshold/2);
		    	spikeSum+=SignalDiffs[i-spikeLength];
			if ((spikeSum<0?-spikeSum:spikeSum)<(spikeThreshold*spikeRelaxPercentage)/100) {
			  // signal has relaxed to start signal of spike within given percent margin
			  break;
			}
		      }
		      if (bHasSharpFallingEdge) {
			// this we can consider a spike
			hSignalSpikeLength->Fill(spikeLength, 1);
		      } else {
			spikeLength=0;
		      }
		    }
		    if (spikeLength>0) {
		      spikeLength--;
		    }
		  }
		  if (pHuffman) {
		    Int_t value=SignalDiffs[i]+signalRange;
		    if (value>=0 && value<2*signalRange) {
		      if (bRunHuffmanTraining) {
			AliHLTUInt64_t v = value;
			pHuffman->AddTrainingValue(v);
			if (signalDiffCutoff>0) {
			  // make a short symbol for cutoff indicator
			  v=signalDiffCutoff+signalRange;
			  pHuffman->AddTrainingValue(v);
			}
		      } else {
			AliHLTUInt64_t length = 0;
			AliHLTUInt64_t v = value;
			pHuffman->Encode(v, length);
			bitcount+=length;
			if (signalDiffCutoff>0 && (SignalDiffs[i]<=-signalDiffCutoff || SignalDiffs[i]>=signalDiffCutoff)) {
			  // encode the cutoff symbol and store the original value
			  v=signalDiffCutoff+signalRange;
			  pHuffman->Encode(v, length);
			  bitcount+=signalBitLength+length;
			} else {
			  bitcountCutoff+=length;
			}
		      }
		    } else {
		      rangeErrorCount++;
		    }
		  }
		}
		if (bitcount>0) {
		  if (hFactor) {
		    bitcount+=(40-bitcount%40); // align to 40 bit altro format
		    float factor=maxChannelLength*signalBitLength;
		    factor/=bitcount;
		    hFactor->Fill(factor);
		  }

		  if (hFactorCutoff) {
		    bitcountCutoff+=(40-bitcountCutoff%40); // align to 40 bit altro format
		    float factorCutoff=maxChannelLength*signalBitLength;
		    factorCutoff/=bitcountCutoff;
		    hFactorCutoff->Fill(factorCutoff);
		  }

		  if (hFactorAltro) {
		    channelWordCount+=(4-channelWordCount%4); // align to groupd of 4 10bit words
		    float factor=channelWordCount*signalBitLength;
		    factor/=bitcount;
		    hFactorAltro->Fill(factor);
		  }
		}

		if (sampleChannelCandidate && channelMaxSignal>sampleMaxSignal) {
		  sampleMaxSignal=channelMaxSignal;
		  if (hSampleChannel) delete hSampleChannel;
		  if (hSampleChannelSignalDiff) delete hSampleChannelSignalDiff;
		  hSampleChannel=new TH1F("hSampleChannel", "Channel Signal (sample)", signalRange, 0, signalRange-1);
		  hSampleChannel->GetXaxis()->SetTitle("time bin");
		  hSampleChannel->GetYaxis()->SetTitle("signal");
		  hSampleChannel->GetYaxis()->SetTitleOffset(1.4);

		  hSampleChannelSignalDiff=new TH1F("hSampleChannelSignalDiff", "Channel Signal Difference (sample)", signalRange, 0, signalRange-1);
		  hSampleChannelSignalDiff->GetXaxis()->SetTitle("time bin");
		  hSampleChannelSignalDiff->GetYaxis()->SetTitle("signal(n+1) - signal(n)");
		  hSampleChannelSignalDiff->GetYaxis()->SetTitleOffset(1.4);
		  for (int i=maxChannelLength-1; i>=0; i--) {
		    hSampleChannel->Fill(i, Signals[i]);
		    hSampleChannelSignalDiff->Fill(i, SignalDiffs[i]);
		  }
		}
    	      } // masked bad channel
    	    } // end of channel loop
    	  } // end of ddl loop
	  cout << "finished event " << eventCount << endl;
    	  eventCount++;
    	} while (rawreader->NextEvent() && (maxEvent<0 || eventCount<maxEvent));
      }
      if (rawreader) delete rawreader;
      rawreader=NULL;
      if (altrorawstream) delete altrorawstream;
      altrorawstream=NULL;
    }
    line.ReadLine(cin);
  }

  cout << " total " << fileCount << " file(s) " << endl;
  // TODO: create statistics from the total equipment size of the TPC

  if (rangeErrorCount>0) {
    cerr << "ERROR: " << rangeErrorCount << " range under/overflow(s)" << endl;
  }
  if (pHuffman && bRunHuffmanTraining) {
    pHuffman->GenerateHuffmanTree();
    pHuffman->Print();
    TFile* htf=TFile::Open(htfn, "RECREATE");
    if (!htf || htf->IsZombie()) {
      cerr << "can not open file " << htfn << endl;
      return;
    }

    htf->cd();
    pHuffman->Write();
    htf->Close();
  }

  if (pHuffman) {
    for (int iSignalDiff=-signalRange; iSignalDiff<signalRange; iSignalDiff++) {
      AliHLTUInt64_t length = 0;
      AliHLTUInt64_t v = iSignalDiff+signalRange;
      pHuffman->Encode(v, length);
      hHuffmanCodeLength->Fill(iSignalDiff, length);
    }
  }

  TFile* of=TFile::Open(targetFileName, "RECREATE");
  if (!of || of->IsZombie()) {
    cerr << "can not open file " << targetFileName << endl;
    return;
  }

  of->cd();
  if (tpcrawstat) {
    tpcrawstat->Print();
    tpcrawstat->Write();
  }
  if (hSignalDiff)                                hSignalDiff->Write();
  if (hSignalSpikeLength)                         hSignalSpikeLength->Write();
  if (hFactor && !bRunHuffmanTraining)            hFactor->Write();
  if (hFactorCutoff && !bRunHuffmanTraining)      hFactorCutoff->Write();
  if (hFactorAltro && !bRunHuffmanTraining)       hFactorAltro->Write();
  if (hHuffmanCodeLength)                         hHuffmanCodeLength->Write();
  if (pHuffman)                                   pHuffman->Write();
  if (hSampleChannel)                             hSampleChannel->Write();
  if (hSampleChannelSignalDiff)                   hSampleChannelSignalDiff->Write();

  of->Close();
}
#endif
